package serie08.asynchrony;import java.util.concurrent.*;public class FutureTaskExecDemo {    /**     * The maximum amount of time the computation may take (in miliseconds).     */    private static int TIME_LIMIT_MS = 20;    public static void main(String args[]) {        FutureTaskExecDemo.demo();    }    public static void demo() {        // Use a cached threadpool as executor service:        ExecutorService executor = Executors.newCachedThreadPool();        System.out.println("Starting FutureDemo.demo()");        startDemoThread(executor, 45);        startDemoThread(executor, 35);        startDemoThread(executor, 20);        startDemoThread(executor, 15);        startDemoThread(executor, 5);        executor.shutdown();    }    protected static void startDemoThread(final ExecutorService executor, final int n) {        System.out.println("CALLING fibonacci(" + n + ")");        // Use java 8 lambda style to submit new callable.        Future<Integer> result = executor.submit(() -> fibonacci(n));        // Pre-java 8:        /*        Future<Integer> result = executor.submit(new Callable<Integer>() {            @Override            public Integer call() throws Exception {                return fibonacci(n);            }        });        */        System.out.println("GOT future(fibonacci(" + n + "))");        try {            // Version without timeout:            //int val = result.get();            int val = result.get(TIME_LIMIT_MS, TimeUnit.MILLISECONDS);            System.out.println("GOT fibonacci(" + n + ") = " + val);        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        } catch (TimeoutException e) {            System.out.println("TIMED OUT future(fibonacci(" + n + "))");        }    }    public static int fibonacci(int n) {        if (n < 2) return 1;        else return fibonacci(n - 1) + fibonacci(n - 2);    }}