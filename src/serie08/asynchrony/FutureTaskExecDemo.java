package serie08.asynchrony;import java.util.concurrent.*;/** * This is a straightforward translation of FutureDemo * to use java.util.concurrent.FutureTask * * @author oscar */public class FutureTaskExecDemo {    public static void main(String args[]) {        FutureTaskExecDemo.demo();    }    public static void demo() {        // Use a cached threadpool as executor service:        ExecutorService executor = Executors.newCachedThreadPool();        System.out.println("Starting FutureDemo.demo()");        startDemoThread(executor, 45);        startDemoThread(executor, 35);        startDemoThread(executor, 20);        startDemoThread(executor, 15);        startDemoThread(executor, 5);    }    protected static void startDemoThread(final ExecutorService executor, final int n) {        System.out.println("CALLING fibonacci(" + n + ")");        // Use java 8 lambda style to submit new callable.        Future<Integer> result = executor.submit(() -> fibonacci(n));        // Pre-java 8:        /*        Future<Integer> result = executor.submit(new Callable<Integer>() {            @Override            public Integer call() throws Exception {                return fibonacci(n);            }        });        */        System.out.println("GOT future(fibonacci(" + n + "))");        try {            int val = result.get().intValue();            System.out.println("GOT fibonacci(" + n + ") = " + val);        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }    public static int fibonacci(int n) {        if (n < 2) return 1;        else return fibonacci(n - 1) + fibonacci(n - 2);    }}